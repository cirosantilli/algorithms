#!/usr/bin/env python

import os
import subprocess
import sys

# Parameters
base_dir = os.path.abspath(os.getcwd())
data_base_dir = os.path.join(base_dir, 'data')
src_dir = os.path.join(base_dir, 'src')
in_ext = '.in'
out_ext = '.out'
class TestDescription:
    def __init__(self, data):
        self.data = data
basenames = {
    'QuickSort.java': TestDescription('sort'),
    'QuickSortTail.java': TestDescription('sort'),
    'Tac.java': TestDescription('tac'),
    'merge_sort.cpp': TestDescription('sort'),
    'quick_sort.cpp': TestDescription('sort'),
    'tac.c': TestDescription('tac'),
}

# Parse command line inputs.
basename = sys.argv[1]
if len(sys.argv) > 1:
    basename = sys.argv[1]
    if not basename in basenames.keys():
        print 'Unknown file: ' + basename
        sys.exit(1);
else:
    print 'Needs one argument.'
    sys.exit(1);

# Determine how to run the output.
basename_noext, lang = os.path.splitext(basename)
lang = lang[1:]
lang_dir = os.path.join(src_dir, lang)
if lang == 'c' or lang == 'cpp':
    run_cmd = [os.path.join(lang_dir, basename_noext + '.out')]
elif lang == 'java':
    run_cmd = ['java', '-cp', lang_dir, basename_noext]

# Build.
os.chdir(lang_dir)
if subprocess.call(['make', '--silent']) != 0:
    print 'Error: Build failed.'
    sys.exit(1);
os.chdir(base_dir)

# Get input data.
data_dir = os.path.join(data_base_dir, basenames[basename].data)
data_basenames = [os.path.splitext(p)[0]
        for p
        in os.listdir(data_dir)
        if os.path.splitext(p)[1] == '.in'
            and os.path.isfile(os.path.join(data_dir, p))]

# Run tests.
for data_basename in data_basenames:
    input_path = os.path.join(data_dir, data_basename) + in_ext
    output_path = os.path.join(data_dir, data_basename) + out_ext
    # For debugging.
    #print run_cmd + [input_path]
    cwd = os.getcwd()
    process = subprocess.Popen(
        run_cmd + [input_path],
        shell  = False,
        stdin  = None,
        stdout = subprocess.PIPE,
        stderr = subprocess.PIPE,
        universal_newlines = True
    )
    stdout, stderr = process.communicate()
    process.wait()
    with open (output_path, 'r') as output_file:
        expected_output = output_file.read()
    if stdout != expected_output:
        print 'Output:\n'
        print stdout
        print '#' * 36
        print 'Expected output:\n'
        print expected_output
        print 'Test failed: ' + input_path
        sys.exit(1);

print 'Tests passed.'
sys.exit(0);
